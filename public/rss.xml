<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title></title>
      <link>https://www.nathanielmott.com</link>
      <description></description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://www.nathanielmott.com/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Fri, 21 Jul 2023 00:00:00 +0000</lastBuildDate>
      <item>
          <title>rust or zig? as of july 2023, i don&#x27;t know</title>
          <pubDate>Fri, 21 Jul 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://www.nathanielmott.com/rust-or-zig-july-2023-idk/</link>
          <guid>https://www.nathanielmott.com/rust-or-zig-july-2023-idk/</guid>
          <description>&lt;p&gt;&lt;em&gt;tl;dr: started at the top, went to the bottom, now we&#x27;re here. wherever that is.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ve spent the last few weeks writing a basic port of the &lt;code&gt;stat&lt;&#x2F;code&gt; command in Rust and Zig. Throughout several iterations of this utility, which has reached the &amp;quot;I&#x27;m willing to discuss this in public&amp;quot; stage but not the &amp;quot;I&#x27;m willing to post the source code&amp;quot; stage, I&#x27;ve had to confront a difficult question: Rust or Zig?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variable-scope&quot;&gt;variable scope&lt;&#x2F;h2&gt;
&lt;p&gt;This utility initially combined a word counter (similar to &lt;code&gt;wc&lt;&#x2F;code&gt;) and &lt;code&gt;stat&lt;&#x2F;code&gt; in a single tool. It seemed like the kind of thing I&#x27;d find useful, and it also required me to learn about parsing arguments in command line utilities, accessing file metadata, and formatting that data into something a human might want to read.&lt;&#x2F;p&gt;
&lt;p&gt;The fundamental problem with this approach is that any method I&#x27;ve found of counting words, lines, and paragraphs changes the time a file was last accessed. This means half the utility (&lt;code&gt;stat&lt;&#x2F;code&gt;) was undermined by the other half (&lt;code&gt;wc&lt;&#x2F;code&gt;) and I&#x27;ve yet to find a solution to this problem that isn&#x27;t &amp;quot;accept inaccuracies with that field.&amp;quot;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Okay. I&#x27;m realizing as I type this that I could gather the &amp;quot;accessed&amp;quot; field before the file&#x27;s contents are read, save that information somewhere, then display the saved information rather than the new information until a new timestamp is recorded.But that would be significantly more complicated than what I currently have.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;So eventually I shifted to &amp;quot;&lt;code&gt;stat&lt;&#x2F;code&gt; but with only the fields I care about.&amp;quot; (Those being the times when a file was created, modified, or accessed.) Huzzah!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;where-zig-and-rust-differ&quot;&gt;where zig and rust differ&lt;&#x2F;h2&gt;
&lt;p&gt;Spoilers: Gathering and presenting this information in the user&#x27;s local timezone is significantly easier in Rust and requires approximately half as many lines of code.But I learned a lot more developing the Zig version of the tool.&lt;&#x2F;p&gt;
&lt;p&gt;Both versions of this utility rely on their respective standard libraries and a crate&#x2F;module for managing dates. That&#x27;s because Rust and Zig both rely on the &lt;code&gt;stat&lt;&#x2F;code&gt; syscall--not to be confused with the command line utility of the same name!--to access file metadata. (At least on Linux; let&#x27;s not discuss Windows just yet.)&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately for me, the &lt;code&gt;stat&lt;&#x2F;code&gt; syscall doesn&#x27;t return the times a file was created, modified, or accessed in a human-readable format. Instead, you get a 128-bit integer representing the number of milliseconds since the Unix epoch time. That means I have to turn the result into something a person can understand.&lt;&#x2F;p&gt;
&lt;p&gt;This is what that code looks like in Rust using the chrono crate:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;    let created: DateTime&amp;lt;Local&amp;gt; =
&lt;&#x2F;span&gt;&lt;span&gt;        DateTime::from(metadata.created().expect(&amp;quot;couldn&amp;#39;t get created&amp;quot;));
&lt;&#x2F;span&gt;&lt;span&gt;    let formatted_created_time = format!(&amp;quot;{}&amp;quot;, created.format(&amp;quot;%m&#x2F;%d&#x2F;%Y %H:%M&amp;quot;));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(Let&#x27;s ignore the fact that I&#x27;m not properly handling optionals or errors there. The important thing is that I was able to specify I wanted the local time.)&lt;&#x2F;p&gt;
&lt;p&gt;This is what the code looks like in Zig:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;    let formatted_created_time = format!(&amp;quot;{}&amp;quot;, created.format(&amp;quot;%m&#x2F;%d&#x2F;%Y %H:%M&amp;quot;));
&lt;&#x2F;span&gt;&lt;span&gt;    const created_local = Datetime.shiftTimezone(created_datetime, &amp;amp;system_tz);
&lt;&#x2F;span&gt;&lt;span&gt;    const created_formatted = try Datetime.formatHttp(created_local, allocator);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Except that doesn&#x27;t show all the work I had to do to get that &amp;quot;system_tz.&amp;quot; That requires a modification to the zig-datetime module I made after reading through the Zig standard library, RFC-8536, and compilation errors for over a day. This is the combination of functions that allows me to get the system timezone on Linux:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;    const system_tz: Timezone = try chrono.get_system_timezone(allocator);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    pub fn get_system_timezone(allocator: std.mem.Allocator) !Timezone {
&lt;&#x2F;span&gt;&lt;span&gt;    const system_time = std.time.timestamp();
&lt;&#x2F;span&gt;&lt;span&gt;    const tzfile = try std.fs.cwd().openFile(&amp;quot;&#x2F;etc&#x2F;localtime&amp;quot;, .{});
&lt;&#x2F;span&gt;&lt;span&gt;    const tzinfo = try std.Tz.parse(allocator, tzfile.reader());
&lt;&#x2F;span&gt;&lt;span&gt;    var current_timetype: std.tz.Timetype = undefined;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for (tzinfo.transitions, 0..) |transition, idx| {
&lt;&#x2F;span&gt;&lt;span&gt;        if (transition.ts &amp;gt; 0 and system_time &amp;lt; transition.ts) {
&lt;&#x2F;span&gt;&lt;span&gt;            current_timetype = tzinfo.transitions[idx - 1].timetype.*;
&lt;&#x2F;span&gt;&lt;span&gt;            break;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    const name = current_timetype.name();
&lt;&#x2F;span&gt;&lt;span&gt;    const offset: i16 = @intCast(@divFloor(current_timetype.offset, 60));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    const System = Timezone.create(name, offset);
&lt;&#x2F;span&gt;&lt;span&gt;    return System;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This: &lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Gets a timestamp of the current system time&lt;&#x2F;li&gt;
&lt;li&gt;Finds and reads the TZif file symlinked to from &#x2F;etc&#x2F;localtime&lt;&#x2F;li&gt;
&lt;li&gt;Determines which &amp;quot;transition&amp;quot; is active&lt;&#x2F;li&gt;
&lt;li&gt;Returns the name of the timezone and the offset from UTC&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;(Oh, and the name doesn&#x27;t actually work, presumably because I haven&#x27;t figured out how to explicitly declare those three bytes as the format Zig uses for strings.)&lt;&#x2F;p&gt;
&lt;p&gt;All of which is to say that it took me several days and several times as many lines of code to accomplish the same result in Zig that I did in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;And I fucking loved it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;casting-fireball-versus-using-a-wand-of-fireballs&quot;&gt;casting fireball versus using a wand of fireballs&lt;&#x2F;h2&gt;
&lt;p&gt;I&#x27;m working on a separate blog post about this, but lately I&#x27;ve been trying to learn programming. I&#x27;ve had several kinda-sorta-failed attempts in the past that left me with a passing knowledge of assignments, control flow, etc. But each time I&#x27;ve felt more like I&#x27;m using a magic item, in D&amp;amp;D parlance, than casting a spell myself.&lt;&#x2F;p&gt;
&lt;p&gt;Rust&#x27;s solution feels more like using a magic item. Zig&#x27;s solution--even though I&#x27;m still largely depending on the standard library and zig-datetime module--feels a lot more like I&#x27;m learning how to cast a spell. Consider that I had to:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Learn how Linux programs check the currently active timezone&lt;&#x2F;li&gt;
&lt;li&gt;Learn how to extract that information from a TZif file&lt;&#x2F;li&gt;
&lt;li&gt;Combine that information with a fairly opinionated existing module&lt;&#x2F;li&gt;
&lt;li&gt;Do all this while also handling allocators, a lack of macros, etc.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;I definitely learned a lot more writing the Zig version of this utility than the Rust version. That was important for this step of my journey to learn programming, and a large part of me would like to stick with Zig for the foreseeable future, especially since I&#x27;m not worried about finding a job or anything like that.&lt;&#x2F;p&gt;
&lt;p&gt;But.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ziggy-without-the-stardust&quot;&gt;ziggy without the stardust&lt;&#x2F;h2&gt;
&lt;p&gt;There&#x27;s no denying that Rust has an advantage when it comes to the developer ecosystem and tooling. Zig is making progress on this front--an official package manager will debut with the formal release of version 0.11 in August--but wrangling with dependencies and the build system is significantly more complex than in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;Zig also has a lot fewer learning resources (though I&#x27;ve found Ziglings particularly useful) and the documentation isn&#x27;t quite to Rust&#x27;s standard. That&#x27;s to be expected! Zig is significantly younger than Rust, hasn&#x27;t reached version 1.0, and sees regular updates between major point upgrades. This iguana&#x27;s always evolving.&lt;&#x2F;p&gt;
&lt;p&gt;But there&#x27;s a difference between learning how a particular function, syscall, or paradigm works and trying to figure out how the fuck I&#x27;m supposed to use the Zig package manager. (Or, failing that, use a Git submodule in a way that makes both my primary Git repository and the Zig build system happy with me.)&lt;&#x2F;p&gt;
&lt;p&gt;Contrast that with the wonders of &lt;code&gt;cargo add&lt;&#x2F;code&gt; and &lt;code&gt;cargo build&lt;&#x2F;code&gt; and it&#x27;s hard not to think the grass is greener on Rust&#x27;s side of the fence--even though I generally prefer Zig&#x27;s syntax, the option to learn more about memory management, and the fact that the resulting binary is a quarter the size even though it&#x27;s not dynamically linked to a number of libraries like the Rust version of this utility is.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;so-where-do-i-go-from-here&quot;&gt;so where do i go from here?&lt;&#x2F;h2&gt;
&lt;p&gt;I told my wife earlier that I almost wish I&#x27;d waited another couple of years to get into programming for the Nth time. By then I expect that Zig would&#x27;ve ironed out the problems with its package manager, introduced even more features, and finalized the much-needed switch to using snake-case for standard library functions. (Heh.)&lt;&#x2F;p&gt;
&lt;p&gt;Right now I&#x27;m not sure what to do. On the one hand, Zig offers a more bottom-up approach to learning that resonates with me, and I could probably devote some of the time I&#x27;d spend exploring other subjects to understanding its build system. On the other hand, Rust would allow me to focus on those other subjects instead.&lt;&#x2F;p&gt;
&lt;p&gt;Part of me wants to continue developing projects in both languages. I&#x27;m not on any particular deadlines; I&#x27;m prioritizing learning over being productive. But I also know my brain, and it doesn&#x27;t like undue hassle, especially when it knows there are alternative solutions just a &amp;quot;.rs&amp;quot; instead of a &amp;quot;.zig&amp;quot; away.&lt;&#x2F;p&gt;
&lt;p&gt;At the moment I&#x27;m leaning towards developing in Rust while keeping pace with Zig updates and potentially supporting the project in other ways. (Money. I mean with money.) This isn&#x27;t my preferred solution due to the binary sizes, dynamic linking,and fugly syntax, but at least I won&#x27;t have to struggle with the build system.&lt;&#x2F;p&gt;
&lt;p&gt;Then again, maybe I&#x27;ll give learning the Zig build system and package management another week or so, especially since the official 0.11 release isn&#x27;t that far away.&lt;&#x2F;p&gt;
&lt;p&gt;Gah!&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>putting the &#x27;personal&#x27; in computer</title>
          <pubDate>Mon, 10 Jul 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://www.nathanielmott.com/putting-the-personal-in-computer/</link>
          <guid>https://www.nathanielmott.com/putting-the-personal-in-computer/</guid>
          <description>&lt;p&gt;&lt;em&gt;tl;dr: you should happen to the computer; the computer shouldn&#x27;t happen to you&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I recently made two seemingly unrelated decisions: switching to Linux and building my own keyboard. While the exact motivations behind these changes vary, at their core, both were prompted by a desire for greater agency.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>switching to a static site</title>
          <pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://www.nathanielmott.com/switching-to-a-static-site/</link>
          <guid>https://www.nathanielmott.com/switching-to-a-static-site/</guid>
          <description>&lt;p&gt;I&#x27;ve used Ghost to host my personal site for a while, but I&#x27;d prefer to have more control over how the site looks than Ghost was willing to give me on the basic plan, and wanted to experiment with a terminal-focused workflow. So here we are.&lt;&#x2F;p&gt;
</description>
      </item>
    </channel>
</rss>
